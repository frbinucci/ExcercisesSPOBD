# -*- coding: utf-8 -*-
"""CVX_Waterfilling.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fqSgfBQblR9ws9t9DOfOnM3Vp_hN6ILt
"""

import cvxpy as cp
import numpy as np
import matplotlib.pyplot as plt
import random

#This function solves the waterfilling problem in CVX
def CVXwaterfilling(N,B,N0,h,Pmax):
    Bc = B/N
    p = cp.Variable(N)

    objective = cp.Maximize(cp.sum(cp.log(1+(cp.multiply(p,h**2))/(Bc*N0))))
    constraints = [p>=0.0,
                   cp.sum(p)<=Pmax]

    prob = cp.Problem(objective,constraints)
    prob.solve()

    return prob.status, prob.value, p.value

#This function solves the waterfilling problem by an iterative homemade procedure
def handMadeWaterfilling(N,B,N0,h,pmax):
  Bc = B/N
  p_noise = (Bc*N0)/(h**2)
  sorted = np.sort(p_noise)
  opt_p = np.zeros(N)
  p_res = Pmax
  level=sorted[0]

  for i in range(0,len(sorted)):
    if i==len(sorted)-1:
        if p_res>0:
            padj = p_res/N;
            level = level+padj
            ploss = p_res
    else:
        residual = sorted[i+1]-level;
        if p_res-residual*len(opt_p[0:i+1])<0:
            padj = p_res/len(opt_p[0:i+1])
            level = level+padj
            ploss = p_res
        else:
            padj = residual;
            level = level+residual
            ploss = padj*len(opt_p[0:i+1])
    opt_p[0:i+1] = opt_p[0:i+1]+padj
    p_res = max(0,p_res - ploss)

  opt_p = np.maximum(0,level-p_noise)

  return opt_p,level


# Press the green button in the gutter to run the script.
if __name__ == '__main__':

    #Setting up the seed for reproducibility
    np.random.seed(10)

    #Mode to test (0 == CVX, 1 == HandMade)
    mode_to_test = 0

    #Channel parameters
    #N = Number of subcarriers
    #B = Total bandwidth
    #Bc = Bandwidth per sub-carrier
    #N0 = Noise Power Spectral Density
    #pl = Average path loss
    #Pmax = Maximum tx power
    N = 16
    B = 20e6
    Bc = B/N
    N0 = 3.98e-21
    pl = 10**(-10)
    Pmax = 1


    #Channel generation
    h = np.sqrt(1 / 2) * abs(np.random.randn(N, 2).view(np.complex128))
    h = np.sqrt(pl) * h
    h = h.flatten()


    if mode_to_test==0:
      [status,value,power_allocation] = CVXwaterfilling(N,B,N0,h,Pmax)
    else:
      [power_allocation,level] = handMadeWaterfilling(N,B,N0,h,Pmax)

    axis = np.linspace(1,N,N)
    snr_inv = (Bc*N0)/(h**2)
    plt.bar(axis,snr_inv, alpha=0.4,label=r'$\frac{1}{\gamma_i}$')
    plt.bar(axis,power_allocation,bottom=snr_inv,alpha=0.4,label=r'$p_{i}$')
    index = np.argmax(power_allocation)
    plt.hlines(y=(power_allocation+snr_inv)[index],xmin=0,xmax=17,linestyle='dashed',linewidth=2,label=r'$\frac{1}{\nu^{*}}$',color='green')
    plt.xticks(axis)
    plt.xlabel("Subcarrier Number",fontsize=14)
    plt.ylabel("Allocated Power [W]",fontsize=14)
    plt.legend(fontsize=11)
    plt.grid()
    plt.show()